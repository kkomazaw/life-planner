import { addMonths, startOfMonth } from 'date-fns';
import type { Asset, AssetHistory, AssetType } from '@/types/asset';
import type { LifeEvent } from '@/types/lifeEvent';
import type { Income, Expense } from '@/types/transaction';
import type { HouseholdMember } from '@/types/household';
import { calculateDateAtAge } from '@/types/household';
import type {
  SimulationSettings,
  SimulationResult,
  MonthlySimulationData,
} from '@/types/simulation';
import { generateAllLifeEvents } from './lifeEventGenerator';

interface SimulationInput {
  settings: SimulationSettings;
  currentAssets: Asset[];
  assetHistory: AssetHistory[];
  lifeEvents: LifeEvent[];
  incomes: Income[];
  expenses: Expense[];
  householdMembers?: HouseholdMember[];
}

/**
 * シミュレーション計算のメイン関数
 * 現在の資産状況から30年分（360ヶ月）の将来予測を計算
 */
export function runSimulation(input: SimulationInput): SimulationResult {
  const { settings, currentAssets, assetHistory, lifeEvents, incomes, expenses, householdMembers } = input;

  const startDate = startOfMonth(new Date());
  const endDate = addMonths(startDate, 360); // 30年 = 360ヶ月

  // 家族メンバーから自動生成されたライフイベントを統合
  const autoGeneratedEvents = householdMembers ? generateAllLifeEvents(householdMembers) : [];
  const allLifeEvents = [...lifeEvents, ...autoGeneratedEvents];

  // デバッグ: 年金イベントを確認
  console.log('=== シミュレーション開始 ===');
  console.log('家族メンバー数:', householdMembers?.length || 0);
  console.log('手動登録ライフイベント数:', lifeEvents.length);
  console.log('自動生成イベント数:', autoGeneratedEvents.length);
  console.log('全ライフイベント数:', allLifeEvents.length);

  // 家族メンバーの詳細
  console.log('\n=== 家族メンバー詳細 ===');
  householdMembers?.forEach((member, idx) => {
    console.log(`[${idx}] ${member.name}:`);
    console.log(`  ID: ${member.id}`);
    console.log(`  生年月日: ${member.birthDate}`);
    console.log(`  年金開始年齢: ${member.pensionStartAge}`);
    console.log(`  期待年金額: ${member.expectedPensionAmount}`);
    console.log(`  退職年齢: ${member.retirementAge}`);
  });

  // 手動登録されたライフイベントを表示
  const manualIncomeEvents = lifeEvents.filter(e => e.category === 'income');
  if (manualIncomeEvents.length > 0) {
    console.log('\n=== 手動登録の収入イベント ===');
    manualIncomeEvents.forEach((event, idx) => {
      console.log(`[${idx}] ${event.name}:`);
      console.log(`  月額: ${event.monthlyAmount}`);
      console.log(`  タイプ: ${event.type}`);
      console.log(`  日付: ${event.date}`);
    });
  }

  // 自動生成された年金イベントを表示
  const pensionEvents = autoGeneratedEvents.filter(e => e.category === 'income');
  console.log('\n=== 自動生成された年金イベント ===');
  console.log('年金イベント数:', pensionEvents.length);
  pensionEvents.forEach((event, idx) => {
    console.log(`[${idx}] ${event.name}:`);
    console.log(`  ID: ${event.id}`);
    console.log(`  月額: ${event.monthlyAmount}`);
    console.log(`  開始日: ${event.date}`);
    console.log(`  カテゴリ: ${event.category}`);
    console.log(`  タイプ: ${event.type}`);
    console.log(`  linkedMemberId: ${event.linkedMemberId}`);
  });

  // 現在の資産残高を取得
  const initialAssets = getCurrentAssetValues(currentAssets, assetHistory);

  // 過去の平均収支を計算（将来予測のベースライン）
  const averageMonthlyIncome = calculateAverageMonthlyIncome(incomes);
  const averageMonthlyExpense = calculateAverageMonthlyExpense(expenses);

  const monthlyData: MonthlySimulationData[] = [];
  let currentDate = startDate;
  let currentAssetsByType = { ...initialAssets };

  // 360ヶ月分をシミュレーション
  for (let i = 0; i < 360; i++) {
    // 1. 運用利回りを適用（月次換算）
    const returnsApplied = applyReturns(currentAssetsByType, settings.expectedReturns);

    // 2. その月の収入を計算
    const monthlyIncome = calculateMonthlyIncome(
      currentDate,
      averageMonthlyIncome,
      settings.futureIncome,
      householdMembers
    );

    // 3. その月の支出を計算
    const monthlyExpense = calculateMonthlyExpense(
      currentDate,
      averageMonthlyExpense,
      settings.futureExpense,
      settings.inflationRate,
      i
    );

    // 4. その月のライフイベント費用を計算（自動生成イベント含む）
    const { lifeEventCost, investmentWithdrawal } = calculateLifeEventCostWithWithdrawal(currentDate, allLifeEvents);

    // 5. 投資資産の取り崩し処理
    let withdrawalAmount = 0;
    if (
      settings.withdrawal?.enabled &&
      settings.withdrawal.monthlyAmount > 0 &&
      currentDate >= settings.withdrawal.startDate
    ) {
      withdrawalAmount = settings.withdrawal.monthlyAmount;
    }

    // ライフイベントとして登録された投資取り崩しも含める
    const totalWithdrawal = withdrawalAmount + investmentWithdrawal;

    // 6. 純キャッシュフロー = 収入（投資取り崩し含む） - 支出 - ライフイベント費用
    const netCashFlow = monthlyIncome + totalWithdrawal - monthlyExpense - lifeEventCost;

    // 7. 運用利回り適用後の資産を更新
    // - 投資資産から取り崩し金額を減額（設定による取り崩し + ライフイベント取り崩し）
    // - 現金にキャッシュフローを加算（取り崩しは既にnetCashFlowに含まれている）
    currentAssetsByType = {
      cash: returnsApplied.cash + netCashFlow,
      investment: returnsApplied.investment - totalWithdrawal,
      property: returnsApplied.property,
      insurance: returnsApplied.insurance,
      other: returnsApplied.other,
    };

    // 8. 総資産残高を計算
    const totalAssets =
      currentAssetsByType.cash +
      currentAssetsByType.investment +
      currentAssetsByType.property +
      currentAssetsByType.insurance +
      currentAssetsByType.other;

    // 9. 月次データを記録（incomeに投資取り崩しを含める）
    monthlyData.push({
      date: currentDate,
      assetBalance: totalAssets,
      assetByType: { ...currentAssetsByType },
      income: monthlyIncome + totalWithdrawal, // 投資取り崩しを収入に含める
      expense: monthlyExpense,
      lifeEventCost,
      netCashFlow,
      withdrawalAmount: totalWithdrawal, // 全ての投資取り崩し（設定 + ライフイベント）
    });

    // 次の月へ
    currentDate = addMonths(currentDate, 1);
  }

  // サマリーを計算
  const summary = calculateSummary(monthlyData, initialAssets);

  return {
    settingsId: settings.id,
    startDate,
    endDate,
    monthlyData,
    summary,
  };
}

/**
 * 現在の資産評価額を資産種別ごとに集計
 */
function getCurrentAssetValues(
  assets: Asset[],
  assetHistory: AssetHistory[]
): Record<AssetType, number> {
  const values: Record<AssetType, number> = {
    cash: 0,
    investment: 0,
    property: 0,
    insurance: 0,
    other: 0,
  };

  assets.forEach((asset) => {
    // 保険の場合は保険金額を資産評価額として使用
    if (asset.type === 'insurance' && asset.coverageAmount) {
      values.insurance += asset.coverageAmount;
      return;
    }

    // その他の資産は履歴から最新値を取得
    const history = assetHistory
      .filter((h) => h.assetId === asset.id)
      .sort((a, b) => b.date.getTime() - a.date.getTime());

    const latestValue = history[0]?.value || 0;
    values[asset.type] += latestValue;
  });

  return values;
}

/**
 * 過去の平均月次収入を計算（メンバー別）
 * linkedMemberIdごとの平均収入を返す
 */
function calculateAverageMonthlyIncome(incomes: Income[]): Map<string, number> {
  if (incomes.length === 0) return new Map();

  // linkedMemberIdごとにグループ化
  const incomesByMember = new Map<string, Income[]>();

  incomes.forEach((income) => {
    const key = income.linkedMemberId || 'unlinked';
    if (!incomesByMember.has(key)) {
      incomesByMember.set(key, []);
    }
    incomesByMember.get(key)!.push(income);
  });

  // 各グループの平均を計算
  const averages = new Map<string, number>();
  incomesByMember.forEach((memberIncomes, memberId) => {
    const total = memberIncomes.reduce((sum, income) => sum + income.amount, 0);
    const average = total / memberIncomes.length;
    averages.set(memberId, average);
  });

  return averages;
}

/**
 * 過去の平均月次支出を計算
 * 各月の支出合計を計算し、その平均を返す
 */
function calculateAverageMonthlyExpense(expenses: Expense[]): number {
  if (expenses.length === 0) return 0;

  // 月ごとにグループ化（YYYY-MM形式）
  const monthlyTotals = new Map<string, number>();

  expenses.forEach((expense) => {
    const yearMonth = `${expense.date.getFullYear()}-${String(expense.date.getMonth() + 1).padStart(2, '0')}`;
    const current = monthlyTotals.get(yearMonth) || 0;
    monthlyTotals.set(yearMonth, current + expense.amount);
  });

  // 各月の合計の平均を計算
  const monthCount = monthlyTotals.size;
  if (monthCount === 0) return 0;

  const totalExpenses = Array.from(monthlyTotals.values()).reduce((sum, amount) => sum + amount, 0);
  return totalExpenses / monthCount;
}

/**
 * 運用利回りを適用（年率を月率に変換して適用）
 */
function applyReturns(
  assets: Record<AssetType, number>,
  expectedReturns: SimulationSettings['expectedReturns']
): Record<AssetType, number> {
  const monthlyReturns = {
    cash: expectedReturns.cash / 12,
    investment: expectedReturns.investment / 12,
    property: expectedReturns.property / 12,
    insurance: expectedReturns.insurance / 12,
    other: expectedReturns.other / 12,
  };

  return {
    cash: assets.cash * (1 + monthlyReturns.cash),
    investment: assets.investment * (1 + monthlyReturns.investment),
    property: assets.property * (1 + monthlyReturns.property),
    insurance: assets.insurance * (1 + monthlyReturns.insurance),
    other: assets.other * (1 + monthlyReturns.other),
  };
}

/**
 * 特定月の収入を計算
 * 家族メンバーの退職日を考慮して、退職後は該当メンバーの収入を0にする
 */
function calculateMonthlyIncome(
  date: Date,
  averageIncomeByMember: Map<string, number>,
  futureIncomes: SimulationSettings['futureIncome'],
  householdMembers: HouseholdMember[] = []
): number {
  let total = 0;

  // ベースライン収入を計算（退職済みメンバーの収入は除外）
  averageIncomeByMember.forEach((averageIncome, memberId) => {
    if (memberId === 'unlinked') {
      // 紐付けされていない収入はそのまま継続
      total += averageIncome;
    } else {
      // メンバーに紐付けられた収入は退職日をチェック
      const member = householdMembers.find((m) => m.id === memberId);
      if (member && member.retirementAge) {
        const retirementDate = calculateDateAtAge(member.birthDate, member.retirementAge);
        // 退職日前なら収入を加算
        if (date < retirementDate) {
          total += averageIncome;
        }
        // 退職日以降は収入0（加算しない）
      } else {
        // 退職年齢が設定されていない場合は継続
        total += averageIncome;
      }
    }
  });

  // 将来の追加収入を加算
  futureIncomes.forEach((income) => {
    if (date >= income.startDate && (!income.endDate || date <= income.endDate)) {
      if (income.frequency === 'monthly') {
        total += income.amount;
      } else if (
        income.frequency === 'annually' &&
        date.getMonth() === income.startDate.getMonth()
      ) {
        total += income.amount;
      }
    }
  });

  return total;
}

/**
 * 特定月の支出を計算（インフレ調整含む）
 */
function calculateMonthlyExpense(
  date: Date,
  baselineExpense: number,
  futureExpenses: SimulationSettings['futureExpense'],
  inflationRate: number,
  monthsElapsed: number
): number {
  // インフレ調整（複利計算）
  const inflationAdjustment = Math.pow(1 + inflationRate / 12, monthsElapsed);
  let total = baselineExpense * inflationAdjustment;

  futureExpenses.forEach((expense) => {
    if (date >= expense.startDate && (!expense.endDate || date <= expense.endDate)) {
      const adjustedAmount = expense.amount * inflationAdjustment;

      if (expense.frequency === 'monthly') {
        total += adjustedAmount;
      } else if (
        expense.frequency === 'annually' &&
        date.getMonth() === expense.startDate.getMonth()
      ) {
        total += adjustedAmount;
      }
    }
  });

  return total;
}

/**
 * 特定月のライフイベント費用を計算（投資取り崩しも分離）
 * 継続イベント（年金など）と一時イベントの両方に対応
 */
function calculateLifeEventCostWithWithdrawal(
  date: Date,
  lifeEvents: LifeEvent[]
): { lifeEventCost: number; investmentWithdrawal: number } {
  let total = 0;
  let investmentWithdrawal = 0;
  let pensionDebug: Array<{name: string, amount: number, included: boolean, reason?: string}> = [];

  lifeEvents.forEach((event) => {
    const eventYear = event.date.getFullYear();
    const eventMonth = event.date.getMonth();
    const currentYear = date.getFullYear();
    const currentMonth = date.getMonth();

    // 後方互換性: typeがない場合は一時イベントとして扱う
    const eventType = event.type || 'oneTime';

    if (eventType === 'oneTime') {
      // 一時イベント: 発生月のみ
      if (eventYear === currentYear && eventMonth === currentMonth) {
        // cost または estimatedCost (後方互換性のため)
        const cost = event.cost !== undefined ? event.cost : (event as any).estimatedCost || 0;
        total += cost;
      }
    } else if (eventType === 'recurring') {
      // 継続イベント: 開始日以降、終了日まで毎月
      const startDate = event.date;
      const endDate = event.endDate;

      const isActive = date >= startDate && (!endDate || date <= endDate);

      if (isActive) {
        // monthlyAmountが負の場合は収入（年金など）、正の場合は支出
        const amount = event.monthlyAmount || 0;

        // 収入カテゴリで正の値（投資取り崩しなど）は投資資産から引く
        if (event.category === 'income' && amount > 0) {
          investmentWithdrawal += amount;
          // デバッグ情報
          pensionDebug.push({
            name: event.name,
            amount,
            included: true
          });
        } else {
          // その他のイベントは通常通りlifeEventCostに加算
          total += amount;

          // 年金（収入）の場合のみデバッグ情報を記録
          if (event.category === 'income') {
            pensionDebug.push({
              name: event.name,
              amount,
              included: true
            });
          }
        }
      } else if (event.category === 'income') {
        // 年金イベントだが条件を満たさない場合
        pensionDebug.push({
          name: event.name,
          amount: event.monthlyAmount || 0,
          included: false,
          reason: `date=${date.toISOString()}, start=${startDate.toISOString()}, isActive=${isActive}`
        });
      }
    }
  });

  // 年金がある月の最初の月だけログ出力（月初のみ）
  if (pensionDebug.length > 0 && date.getDate() === 1 && date.getMonth() === 0) {
    console.log(`${date.getFullYear()}年1月の年金詳細:`);
    pensionDebug.forEach((item, index) => {
      console.log(`  [${index}] ${item.name}: ${item.amount}円 (含む: ${item.included})${item.reason ? ' - ' + item.reason : ''}`);
    });
    console.log(`  lifeEventCost合計: ${total}円`);
    console.log(`  investmentWithdrawal合計: ${investmentWithdrawal}円`);
  }

  // デバッグ: 11年後の1月だけ全イベントを確認
  if (date.getFullYear() === new Date().getFullYear() + 11 && date.getMonth() === 0 && date.getDate() === 1) {
    console.log('=== 11年後1月: 全ライフイベント詳細 ===');
    console.log('ライフイベント総数:', lifeEvents.length);
    lifeEvents.forEach((event, idx) => {
      console.log(`[${idx}] ${event.name}:`);
      console.log(`  category: ${event.category}`);
      console.log(`  type: ${event.type}`);
      console.log(`  monthlyAmount: ${event.monthlyAmount}`);
      console.log(`  date: ${event.date}`);
      console.log(`  endDate: ${event.endDate}`);
      if (event.type === 'recurring') {
        const isActive = date >= event.date && (!event.endDate || date <= event.endDate);
        console.log(`  isActive: ${isActive}`);
      }
    });
    console.log('この月のlifeEventCost:', total);
    console.log('この月のinvestmentWithdrawal:', investmentWithdrawal);
  }

  return { lifeEventCost: total, investmentWithdrawal };
}

/**
 * 特定月のライフイベント費用を計算（後方互換性のため）
 * 継続イベント（年金など）と一時イベントの両方に対応
 */
function calculateLifeEventCost(date: Date, lifeEvents: LifeEvent[]): number {
  let total = 0;
  let pensionDebug: Array<{name: string, amount: number, included: boolean, reason?: string}> = [];

  lifeEvents.forEach((event) => {
    const eventYear = event.date.getFullYear();
    const eventMonth = event.date.getMonth();
    const currentYear = date.getFullYear();
    const currentMonth = date.getMonth();

    // 後方互換性: typeがない場合は一時イベントとして扱う
    const eventType = event.type || 'oneTime';

    if (eventType === 'oneTime') {
      // 一時イベント: 発生月のみ
      if (eventYear === currentYear && eventMonth === currentMonth) {
        // cost または estimatedCost (後方互換性のため)
        const cost = event.cost !== undefined ? event.cost : (event as any).estimatedCost || 0;
        total += cost;
      }
    } else if (eventType === 'recurring') {
      // 継続イベント: 開始日以降、終了日まで毎月
      const startDate = event.date;
      const endDate = event.endDate;

      const isActive = date >= startDate && (!endDate || date <= endDate);

      if (isActive) {
        // monthlyAmountが負の場合は収入（年金など）、正の場合は支出
        const amount = event.monthlyAmount || 0;
        total += amount;

        // 年金（収入）の場合のみデバッグ情報を記録
        if (event.category === 'income') {
          pensionDebug.push({
            name: event.name,
            amount,
            included: true
          });
        }
      } else if (event.category === 'income') {
        // 年金イベントだが条件を満たさない場合
        pensionDebug.push({
          name: event.name,
          amount: event.monthlyAmount || 0,
          included: false,
          reason: `date=${date.toISOString()}, start=${startDate.toISOString()}, isActive=${isActive}`
        });
      }
    }
  });

  // 年金がある月の最初の月だけログ出力（月初のみ）
  if (pensionDebug.length > 0 && date.getDate() === 1 && date.getMonth() === 0) {
    console.log(`${date.getFullYear()}年1月の年金詳細:`);
    pensionDebug.forEach((item, index) => {
      console.log(`  [${index}] ${item.name}: ${item.amount}円 (含む: ${item.included})${item.reason ? ' - ' + item.reason : ''}`);
    });
    console.log(`  合計: ${total}円`);
  }

  // デバッグ: 11年後の1月だけ全イベントを確認
  if (date.getFullYear() === new Date().getFullYear() + 11 && date.getMonth() === 0 && date.getDate() === 1) {
    console.log('=== 11年後1月: 全ライフイベント詳細 ===');
    console.log('ライフイベント総数:', lifeEvents.length);
    lifeEvents.forEach((event, idx) => {
      console.log(`[${idx}] ${event.name}:`);
      console.log(`  category: ${event.category}`);
      console.log(`  type: ${event.type}`);
      console.log(`  monthlyAmount: ${event.monthlyAmount}`);
      console.log(`  date: ${event.date}`);
      console.log(`  endDate: ${event.endDate}`);
      if (event.type === 'recurring') {
        const isActive = date >= event.date && (!event.endDate || date <= event.endDate);
        console.log(`  isActive: ${isActive}`);
      }
    });
    console.log('この月の合計lifeEventCost:', total);
  }

  return total;
}

/**
 * シミュレーション結果のサマリーを計算
 */
function calculateSummary(
  monthlyData: MonthlySimulationData[],
  initialAssets: Record<AssetType, number>
): SimulationResult['summary'] {
  const initialTotal =
    initialAssets.cash + initialAssets.investment + initialAssets.property + initialAssets.insurance + initialAssets.other;

  let maxAssetBalance = initialTotal;
  let minAssetBalance = initialTotal;
  let totalIncome = 0;
  let totalExpense = 0;
  let totalLifeEventCost = 0;
  const warningMonths: Date[] = [];

  monthlyData.forEach((data) => {
    if (data.assetBalance > maxAssetBalance) {
      maxAssetBalance = data.assetBalance;
    }
    if (data.assetBalance < minAssetBalance) {
      minAssetBalance = data.assetBalance;
    }
    if (data.assetBalance < 0) {
      warningMonths.push(data.date);
    }

    totalIncome += data.income;
    totalExpense += data.expense;
    totalLifeEventCost += data.lifeEventCost;
  });

  const finalAssetBalance = monthlyData[monthlyData.length - 1]?.assetBalance || 0;

  return {
    finalAssetBalance,
    maxAssetBalance,
    minAssetBalance,
    totalIncome,
    totalExpense,
    totalLifeEventCost,
    warningMonths,
  };
}
